//----------операторы--------------------//
3+4  
2*3  
1 / 2   // = 0.5 в javascript
//Пример: бесконечность
2.0 / 0    // = Infinity
2.0 / 0.0  // = Infinity
2.0 / -0.0 // = -Infinity

// % (Модуль числа) 
//Этот оператор возвращает значение остатка при делении первого операнда на второй. Результат будет иметь тот же знак, что и первый операнд.
7 % 2  // = 1
-1 % 2 // -1
// ++ (Инкремент)
x=3
y = x++ // увеличивает x до 4, устанавливает y=3

x=3
y = ++x // увеличивает x до 4, устанавливает y=4

// -- (Декремент) Аналогично инкременту, но уменьшает на единицу.


//- (Унарный минус) Возвращает число, противоположное по знаку данному.

//+ (Унарный плюс)
//Возвращает операнд.

//Как и любые арифметические операторы, делает неявное преобразование операнда в число, поэтому используется просто для перевода переменной из числовой в строковую.

var value = input.value
value = +value
if (isNaN(value)) alert('не число')

//--------------NaN--------------------//
//Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).

//Например, деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:
alert( 0 / 0 ); // NaN	

// isNaN //
//Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.
var n = 0 / 0;

alert( isNaN(n) ); // true
alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
//Любая операция с NaN возвращает NaN.
alert( NaN + 1 ); // NaN

//--/важно/--// 
//Математические операции в JS безопасны
//Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу.
//В худшем случае, результат будет NaN

//-------------isFinite(n)--------------------//
//Итак, в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.
//Тот факт, что они, хоть и особые числа, демонстрируется работой оператора +:
var value = prompt("Введите Infinity", 'Infinity');

var number = +value;

alert( number ); // Infinity, плюс преобразовал строку "Infinity" к такому "числу"
//Обычно если мы хотим от посетителя получить число, то Infinity или NaN нам не подходят. Для того, чтобы отличить «обычные» числа от таких специальных значений, существует функция isFinite.
//Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
alert( isFinite(1) ); // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) ); // false

//----------Преобразование к числу--------------------//
//Большинство арифметических операций и математических функций преобразуют значение в число автоматически.
//Для того, чтобы сделать это явно, обычно перед значением ставят унарный плюс '+':
var s = "12.34";
alert( +s ); // 12.34
//При этом, если строка не является в точности числом, то результат будет NaN:
alert( +"12test" ); // NaN
//Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются:
alert( +"  -12" ); // -12
alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
alert( +"" ); // 0, пустая строка становится нулем
alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
alert( '12.34' / "-2" ); // -6.17


//----------Мягкое преобразование: parseInt и parseFloat--------------------//
//В мире HTML/CSS многие значения не являются в точности числами. Например, метрики CSS: 10pt или -12px.

//Оператор '+' для таких значений возвратит NaN:
alert(+"12px") // NaN
//Для удобного чтения таких значений существует функция parseInt:
alert( parseInt('12px') ); // 12
//Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
//При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное.
alert( parseInt('12px') ) // 12, ошибка на символе 'p'
alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
//существуют ситуации, когда parseInt/parseFloat возвращают NaN. Это происходит при ошибке на первом же символе:
alert( parseInt('a123') ); // NaN

//Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
alert( parseInt('FF', 16) ); // 255

//----------Проверка на число--------------------//
//Для проверки строки на число можно использовать функцию isNaN(str).
//Она преобразует строку в число аналогично +, а затем вернёт true, если это NaN, т.е. если преобразование не удалось:
var x = prompt("Введите значение", "-11.5");

if (isNaN(x)) {
  alert( "Строка преобразовалась в NaN. Не число" );
} else {
  alert( "Число" );
}

//Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
//Так устроена функция parseFloat: она преобразует аргумент к строке, т.е. true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.

//----------toString(система счисления)--------------------//
//Как показано выше, числа можно записывать не только в 10-чной, но и в 16-ричной системе. Но бывает и противоположная задача: получить 16-ричное представление числа. Для этого используется метод toString(основание системы), например:
var n = 255;

alert( n.toString(16) ); // ff
//В частности, это используют для работы с цветовыми значениями в браузере, вида #AABBCC.
//Основание может быть любым от 2 до 36.

//Основание 2 бывает полезно для отладки побитовых операций:
var n = 4;
alert( n.toString(2) ); // 100
//Основание 36 (по количеству букв в английском алфавите – 26, вместе с цифрами, которых 10) используется для того, чтобы «кодировать» число в виде буквенно-цифровой строки. В этой системе счисления сначала используются цифры, а затем буквы от a до z:
var n = 1234567890;
alert( n.toString(36) ); // kf12oi

//При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.


////----------Округление--------------------//

//Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.

Math.floor
//Округляет вниз
Math.ceil
//Округляет вверх
Math.round
//Округляет до ближайшего целого

alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

////----------Округление битовыми операторами--------------//
//Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.

//В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его:
alert( ~~12.3 ); // 12
//Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем:
alert( 12.3 ^ 0 ); // 12
alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
//Это удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки как Math.floor(...):
var x = a * b / c ^ 0; // читается как "a * b / c и округлить"

////----------Округление до заданной точности-------------//
//Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2-го знака после запятой:
var n = 3.456;
alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
// Таким образом можно округлять число и вверх и вниз.

////----------num.toFixed(precision)------------//
//Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки:
var n = 12.34;
alert( n.toFixed(1) ); // "12.3"

//Округление идёт до ближайшего значения, аналогично Math.round:
var n = 12.36;
alert( n.toFixed(1) ); // "12.4"

//Итоговая строка, при необходимости, дополняется нулями до нужной точности:
var n = 12.36;
alert( n.toFixed(1) ); // "12.4"
//Если нам нужно именно число, то мы можем получить его, применив '+' к результату n.toFixed(..):
var n = 12.34;
alert( +n.toFixed(5) ); // 12.34

////----------Метод toFixed не эквивалентен Math.round!------------//
//Например, произведём округление до одного знака после запятой с использованием двух способов: toFixed и Math.round с умножением и делением:
var price = 6.35;

alert( price.toFixed(1) ); // 6.3
alert( Math.round(price * 10) / 10 ); // 6.4
//Как видно, результат разный! Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.  

//////----------Метод toFixed не эквивалентен Math.round!------------//
//Запустите этот пример:
alert( 0.1 + 0.2 == 0.3 ); //вывел false
//Хорошо, теперь мы можем быть уверены: 0.1 + 0.2 это не 0.3. Но тогда что же это?
alert( 0.1 + 0.2 ); // 0.30000000000000004
//Как видите, произошла небольшая вычислительная ошибка, результат сложения 0.1 + 0.2 немного больше, чем 0.3
alert( 0.1 + 0.2 > 0.3 ); // true
//Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.

//Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является 0.2 (=2/10).

//Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. Её даже можно увидеть:
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
//Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.

//Конечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.
//Например, есть два способа сложить 0.1 и 0.2:

//Сделать их целыми, сложить, а потом поделить:
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
//Это работает, т.к. числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.
//Сложить, а затем округлить до разумного знака после запятой. Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:

var result = 0.1 + 0.2;
alert( +result.toFixed(10) ); // 0.3

//Забавный пример
//Привет! Я – число, растущее само по себе!
alert( 9999999999999999 );   // выведет 100000000000000000
//Причина та же – потеря точности.
//Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

//Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».

//Ради справедливости заметим, что в точности то же самое происходит в любом другом языке, где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl.


////----------Тригонометрия-----------//
//Встроенные функции для тригонометрических вычислений:
Math.acos(x)
//Возвращает арккосинус x (в радианах)
Math.asin(x)
//Возвращает арксинус x (в радианах)
Math.atan(x)
//Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
//Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
//Вычисляет синус x (в радианах)
Math.cos(x)
//Вычисляет косинус x (в радианах)
Math.tan(x)
//Возвращает тангенс x (в радианах)

////----------Функции общего назначения-----------//

//Разные полезные функции:

Math.sqrt(x)
//Возвращает квадратный корень из x.
Math.log(x)
//Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
//Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
//Возвращает абсолютное значение числа
Math.exp(x)
//Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)
//Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
//Возвращает наименьший из списка аргументов
Math.random()
//Возвращает псевдо-случайное число в интервале [0,1) – то есть между 0(включительно) и 1(не включая). Генератор случайных чисел инициализуется текущим временем.


////---------Форматирование----------//
//Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():
var number = 123456789;

alert( number.toLocaleString() ); // 123 456 789